%=========================================

%   Einleitung     =

%=========================================


\chapter{SDH Versuch}

\section{Allgemeine Beschreibung der Versuche}

%Kurze Einleitung ins Thema

Der folgende Versuch handelt von der Multiplextechnik SDH. SDH steht
Synchrone Digitale Hierarchie die es möglich macht, niederratige
Datenströme zu einem hochrratigen Datenstrom zu multiplexen, das Netz
taktet dabei vollkommen synchron. 
%In unserem Versuchsaufbau werden wir absichtlich verschiedene Fehler einspeisen sowie uns die Pointeraktivitäten im Netz genauer ansehen. 
In unserem Versuch haben wir die Möglichkeit, Fehler in das Netz einzuspeisen und die Reaktion darauf zu beobachten. Die Möglichkeit Fehler einzuspeisen wird uns durch den Multifunktionstester GN Elmi EST 2100 ermöglicht, der ebenfalls als Multiplexer fungiert. Der GN Elmi EST 2100 beherrscht die No7 Protokolle und wird direkt mit einem Lichtwellenleiter in das Netz eingebunden. Das Auswerten dieser Fehler ist über die Software Telecommunications-Management-Network-Software von Siemens gegeben. Der Rechner auf dem die Software läuft ist über die QST-E3 Schnittstelle mit den SMA 16 Multiplexern verbunden und sammelt so die nötigen Daten.

Die Multiplexer sind mit Lichtwellenleiter verbunden die theoretisch eine Entfernung von ca. 50Km schaffen würden. Da Elmi leider nicht von Siemens ist, ist es auch nicht möglich direkt über die Software zu sehen wie Elmi sich als Multiplexer verhält.


\begin{figure}[htbp] 
  \centering
    \includegraphics[width=1\textwidth]{tkinhalt/sdh/versuchsaufbau.png}
  \caption{Versuchsaufbau}
  \label{versuchsaufbau}
\end{figure}

\section{Versuchsgegenstände im Detail}

Vor dem Versuch betrachten wir uns die TMNS und den Elmi genauer.

\subsection{GN Elmi EST 2100}


%Elmi ist ein Messgerät das direkt mit den anderen Multiplexern über einen Lichtwellenleiter angeschlossen ist. Er fungiert in erster Linie zum Einspeisen von Fehlern ins Netz um zu betrachten wie sich das SDH darauf verhält. Wie oben bereits erwähnt ist er selbst ebenfalls Teil des Netzes in Form von einem Multiplexers. Folgende Grafiken erläutern wie mit dem Gerät um zu gehen ist.

Der CN Elmi EPT2100 ist ein PCM Tester. Er erlaubt Manipulationen auf der SDH Leitung oder das direkte Einspeisen von Fehlermeldungen. Für das Netz verhält sich der Elmi wie ein Multiplexer. Manipulationen können beispielsweise das direkte Einspeisen von Pointern oder Taktverschiebungen im Netz sein. Ein Beispiel für eine eingespeiste Fehlermeldung kann eine LOS Meldung sein, die direkt auf die Leitung gegeben wird. Obwohl der Elmi zum Simulieren gebaut wurde, ist er mit Lichtwellenleitern an das SDH Netz angebunden. Dadurch kann sehr realitätsnah gearbeitet werden.

\begin{figure}[H] 
	\centering
	\includegraphics[width=.8\textwidth]{tkinhalt/sdh/elmi_start.png}
	\caption{Startbildschirm GN Elmi EST 2100}
	\label{startbildschirm_elmi}
\end{figure}

Es gibt es veschiedene Möglichkeiten das Netz zu beeinflussen. Da Elmi einen eigenen internen Systemtakt besitzt, kann man diesen auch verwenden um so beispielsweise zwei verschiedene Takte im Netz zu simulieren. Das entspricht der reellen Situation, dass Netzgrenzen nicht synchronisiert sind oder ein Multiplexer nicht mit dem Systemtakt im Netz arbeitet. Unter den Menüpunkt Ref. kann man diesen dann beeinflussen.


\todo{Bild von Taktmenu}


Eine weitere, für unseren Versuch wichtige, Funktion bietet die Sektion ALARM. Hier kann man nach Belieben Fehler ins Netz einspeisen. Diese kann man entweder als Pulse, das bedeutet über einen bestimmten Zeitrahmen, oder kontinuierlich setzen. \textcolor{red}{Für unserem Versuch werden nur diese zwei Sektionen benötigt deswegen wird hier nicht weiter auf die Funktionalität von Elmi eingegangen.}$\Rightarrow$ und wie haben wir Pointer gesetzt?

\begin{figure}[H] 
	\centering
	\includegraphics[width=0.9\textwidth]{tkinhalt/sdh/elmi_fehler.png}
	\caption{Fehlermenu GN Elmi EST 2100}
	\label{fehlermenu_elmi}
\end{figure}

\subsection{TMNS}

Die TMNS ist zur Analyse und Überwachung des SDH-Netzes hilfreich. In der Hauptansicht wird das Netz sche­ma­tisch für eine gute Übersicht dargestellt. Klickt man nun in unserem Testnetz \textit{Köln} auf die Performancemessung, gelangt man in die für den Versuch interessante Performanceansicht. 

\begin{figure}[H] 
	\centering
	\includegraphics[width=0.9\textwidth]{tkinhalt/sdh/tnms.jpg}
	\caption{Telecommunications-Management-Network-Software}
	\label{TMNS}
\end{figure}

Im Hauptfenster werden sämtliche Komponenten angezeigt, die zu dem Netz gehören, bis auf Elmi. Hier werden auch bei auftretenden Fehlern die betroffenen Komponenten durch ein rotes Blinken markiert. In der Abbildung \ref{tms_incoming} ist zu sehen, wie die Komponente im Steckplatz 406 auf Port 3 einen einkommenden Fehler anzeigt. 

Dass die Ports 1 und 2  ebenfalls rot markiert sind liegt aber daran, dass die Ports zwar konfiguriert sind aber kein Kabel angeschlossen haben. Diese Meldungen sind keine echten Fehler, also können wir diese einfach ignorieren.


\begin{figure}[H] 
	\centering
	\includegraphics[width=0.7\textwidth]{tkinhalt/sdh/Fehler2.jpg}
	\caption{Einkommender Fehler im TMNS}
	\label{tms_incoming}
\end{figure}

Bei einem auftretenden Fehler kann man sich nun die Komponente genauer anschauen indem man den entsprechenden Port auswählt. Durch Auswahl der Submenue-View gelangt man in eine Ansicht in der man genauer sehen kann wo der Fehler entstanden ist.


\begin{figure}[H] 
	\centering
	\includegraphics[width=0.7\textwidth]{tkinhalt/sdh/komponent-performance.jpg}
	\caption{Traffic Flow Fenster}
	\label{traficflow_fenster}
\end{figure}

Hier hat man nun, je nach Fehler, die Auswahl. Wenn es um Pointer geht wird hier im Normalfall das AU-4 Fenster anfangen zu blinken, wenn ein Netz-Fehler auftritt das STM-1 Fenster.

Im Versuchsverlauf werden die Auswirkungen von Fehlern getestet und weiter betrachtet. 

Die Abbildung \ref{pointerview} zeigt die Performance-Ansicht des AU-4 Fensters.

\begin{figure}[H] 
	\centering
	\includegraphics[width=0.9\textwidth]{tkinhalt/sdh/Pointerview_detail.jpg}
	\caption{Pointerview zur überwachung der Aktivitäten in AU4}
	\label{pointerview}
\end{figure}

%zur pointerview was schreiben

Das AU-4 Fenster beinhaltet:


\begin{itemize}

\item Date - Das Aktuelle Datum

\item Time - Die Aktuelle Zeit

\item TMP - Dauer des gemessenen Intervalls

\item -PJE - Die gezählten Negativ Pointer-Vorgänge

\item +PJE - Die gezählten Positiv Pointer-Vorgänge

\end{itemize}


Die Aktualisierung der Daten findet nur manuell mit dem Update Knopf statt. TMP ist hier im Auge zu behalten da die Daten alle 15 Minuten in eine Log-Datei geschrieben werden und sowohl der Timer, als auch die Messwerte zurück gesetzt werden. Die Log-Dateien sind in den Reitern \textit{Previous 15min} und \textit{Previous 24h} wieder zu finden.


Um im genau zu sehen was im STM-1 vor sich geht, kann man sich hier ebenfalls die Performance-Ansicht anzeigen lassen.

\begin{figure}[H] 
	\centering
	\includegraphics[width=0.9\textwidth]{tkinhalt/sdh/ms-near-end.jpg}
	\caption{STM1 Performance Fenster}
	\label{stm1_fenster}
\end{figure}

Folgende Daten werden angezeigt:


\begin{itemize}

\item Date - Das Aktuelle Datum

\item Time - Die Aktuelle Zeit

\item TMP - Dauer des gemessenen Intervalls

\item BBE - Background Block Error

\item ES - Errored Seconds

\item SES - Severely Errored Seconds

\item UAS - Unavailable Seconds

\end{itemize}

Das Aktualisieren und das Speichern in die Log Dateien wurde bereits beschrieben.

Die Fehlerrate wird in Error-Sekunden angegeben die unterschiedliche Aussagen über den Fehler angeben.


\begin{itemize}

\item ES - beinhaltet, dass innerhalb einer Sekunde ein, oder mehrere, fehlerhafte Blöcke aufgetreten sind.

\item SES - beinhaltet, dass innerhalb einer Sekunde 30 Prozent fehlerhafte Blöcke aufgetreten sind.

\item UAS - Nach 11 SES gilt eine Leitung als nicht mehr verfügbar. Nach 11 Sekunden ohne SES gilt sie wieder als verfügbar.

\end{itemize}





\section{Fehlereinspeisung}

Nachdem wir alle für den Versuch erforderlichen Komponenten kennengelernt haben, können wir nun mit dem eigentlichen Versuch beginnen. 

Im Folgenden sollen drei verschiedene Fehlermeldungen mit Hilfe von Elmi eingespeist werden. Diese Fehler werden nicht tatsächlich verursacht, Elmi verhält sich nur wie ein MUX, bei dem die Fehler aufgetreten sind und speist die Meldungen ein. 

Die Meldungen werden in verschiedenen Schritten sowohl kontinuierlich, als auch als Burst eingespeist. 

Wenn im empfangenen Signal Bitfehler enthalten sind, sendet der Empfänger eine Alarm-Nachricht in Senderichtung zurück. Bei dieser Rückmeldung spricht man von REI (Remote Error Indication). Die für uns wichtigen sind:\todo{Das Steht irgendwie alleine und ich kann nichts damit anfangen}


\begin{itemize}

\item LOS - Lost of Singnal, Rückgang der eingehenden optischen Leistungspegel, verursacht hohe Bitfehlerrate

\item MS-AIS - Multiplex Section Alarm Indication Signal, wird ausgelöst wenn K2 (bits 6, 7, 8) auf 111 gesetzt ist für mehr als 3 Frames.

\item LOF - Lost of Frame tritt auf wenn das Signal für mehr als 3 ms OOF (Out of Frame) ist.

\item OOF - Out of Frame tritt auf wenn die Bytes A1 und A2 länger als 624 $\mu s$   fehlerhaft sind 

\end{itemize}


Sind im empfangenen Signal Bitfehler enthalten, meldet der Sensor BIP Errors. Da das nicht gleichbedeutend mit dem Ausfall der Verbindung ist, spricht man von einer Anomalie, die in Senderichtung zurückgemeldet wird. Die Rückmeldung wird als REI (Remote Error Indication) bezeichnet.




\subsubsection{Kontinuierliches Fehlereinspeisen}

Zuerst werden wir die Fehler kontinuierlich einspeisen. Nach dem Absenden der Fehler fängt in der TMNS die entsprechende Komponente an zu blinken. Im Menü arbeiten wir uns bis zum STM-1 Performance-Fenster \ref{stm1_hohe_uas} durch. 

\begin{figure}[H] 
	\centering
	\includegraphics[width=0.9\textwidth]{tkinhalt/sdh/stm1-konti.jpg}
	\caption{STM1 Performance Fenster mit hoher UAS-Rate}
	\label{stm1_hohe_uas}
\end{figure}


Die Ergebnisse sind alle, wie zu erwarten, gleich. Alle drei Fehlermeldungen lassen den UAS-Counter solange ansteigen bis man aufhört den Fehler einzuspeisen. Da alle drei Fehler kontinuierlich auftreten, verursachen sie dauerhaft SES und somit nach kurzer Zeit UAS. Kontinuierliche Fehler sind sehr schwerwiegend und sofort zu behandeln.

Hier noch einmal ein Tabellarischer Überblick über alle gemessenen Daten:


\begin{table}[H]
	\centering
	\begin{tabular}{|*{6}{c|}}
		\hline
		Fehlermeldung & Burst-Time & ES & SES & UAS & Fenster \\
		\hline
		\hline
		MS-AIS & Kontinuierlich & 0 & 0 & ++ & STM1 \\
		\hline
		LOS & Kontinuierlich & 0 & 0 & ++ & STM1 \\
		\hline
		LOF & Kontinuierlich & 0 & 0 & ++ & STM1 \\
		\hline
	\end{tabular}
	\caption{Kontinuierliches steigen der UAS solange die Fehlermeldung eingespeist wird}
\end{table}

\todo{Und was sagt die Tabelle jetzt?}

\subsubsection{Burst Fehlereinspeisung}

Nachdem wir die Fehlermeldungen kontinuierlich eingespeist haben, speisen wir eine MS-AIS und ein LOS jeweils als Burst ein. Die Bursts haben je eine Dauer von 100ms, einer Sekunde und sieben Sekunden. \todo{Ist die Pule Length die Zeit, in der die Dinger eingespeist werden, oder heißt das, dass die dinger alle ... Sekunden eingespeist werden?}
%innerhalb von 100ms, einer Sekunde, und sieben Sekunden.

\begin{table}
\begin{tabular}{|*{6}{c|}} 
\hline 
Fehlermeldung & Burst-Time & ES & SES & UAS & Fenster \\
\hline 
\hline 
MS-AIS & 100 ms & 1 & 1 & 0 &STM1 \\
\hline 
MS-AIS & 1 s & 2 & 2 & 0 & STM1 \\
\hline 
MS-AIS & 7 s & 8 & 8 & 0 & STM1 \\
\hline 
LOS & 100 ms & 3 & 3 & 0 & STM1 \\
\hline 
LOS & 1 s & 4 & 4 & 0 & STM1 \\
\hline 
LOS & 7 s & 0 & 0 & 14 & STM1 \\
\hline 
\end{tabular}
\centering
\caption{Konsequenzen auf verschieden lange Fehlermeldungen}
\end{table}
\vspace{1 cm}

Wie man anhand der Tabelle sehen kann löst die MS-AIS lediglich maximal 8 SES aus und somit wird die Leitung nicht als unavailable gesetzt.

Zu beobachten war, dass bei den kurzen Bursts die TMNS überhaupt gar nicht auf den Fehler reagiert. Das ist erklärbar, da die  Fehlereinspeisung endet, bevor der Fehler erkannt wird. Bei den LOS Alarmen sind die Error Sekunden schon beträchtlich höher. Ein sieben Sekunden langer LOS kann die Leitung bereits für einige Momente auf \glqq unavalible\grqq~setzen, wie man an dem UAS Feld erkennen kann.


\subsection{Pointer}
Um zu verstehen, was ein Pointer ist, muss man sich einen SDH Rahmen genauer ansehen. Ein SDH Rahmen besteht aus Overhead (Steuerdaten) und Payload (Nutzdaten und weitere Daten). Ein Pointer zeigt auf den Beginn der Nutzdaten im Payload. Besonders beim Multiplexen von mehreren SDM-n Rahmen zu einem SDM-(n+1) Rahmen müssen die ursprünglichen Payload Bereiche adressierbar bleiben. 

Da das SDH-Netz ein voll getaktetes Netz ist, kann es bei Taktverschiebungen zu einem Datenverlust, bzw. zu Zugriffen auf die falschen Bits kommen. Um diese Taktverschiebungen auszugleichen, ist es möglich, Leer-Bytes einzufügen, oder den Payload früher zu senden. Diese Verschiebungen werden Poinerjustierung genannt. Eine Pointerjustierung kann aber nur in jedem vierten gesendeten Rahmen statt finden und muss angekündigt sein.

%und so durch Taktunterschiede es theoretisch zu einer Überlast kommen kann, gibt es Pointer. 
%Diese sind in der Administrative Unit zu finden und zeigen auf die Position der Nutzinfomrationen im Payload Bereich. Durch Pointer ist es möglich die Taktunterschiede, durch einfügen von Leer-Bytes oder früheres Senden von Payload, auszugleichen. Es können allerdings nur in jedem vierten Rahmen nach Ankündigung die Pointer angepasst werden.

In diesem Versuch beschäftigen wir uns mit dem Dekrementieren und Inkrementieren von Pointern, also einer negativen und einer positiven Verschiebung von Pointern. Zusätzlich dazu werden wir ausprobieren, was passiert, wenn der Systemtakt gestört wird.


\subsubsection{Manuelles negativ und positiv Justieren}

Elmi hat für die Justierung des Pointers ein eigenes Menue. Hier kann man einstellen, ob man die Pointer-Justierung dauerhaft alle 1500 ms oder manuell durchführen will.

\begin{figure}[H] 
	\centering
	\includegraphics[width=0.7\textwidth]{tkinhalt/sdh/IMG_1937.JPG}
	\caption{Dekrementieren des Pointers}
	\label{dekrement_pointer}
\end{figure}

Zuerst dekrementieren wir den Pointer was ein Pointer Justification Event auslöst und in TMNS im Performance Menu von AU-4 als -PJE-Erhöhung wahrzunehmen ist.

Entsprechend umgekehrt verhält sich das System bei einer Inkrementierung des Pointers. Im Versuch war zu erkennen, dass die ersten drei gesendeten Werte nicht in dem Perfomance-Fenster sichtbar waren. Dies ist darauf zurück zu führen das nur bei jedem vierten Rahmen eine Pointer-Aktivität durchgeführt wird. Also wurden die ersten drei als Ankündigung verstanden das nun der Pointer geändert wird. \todo{stimmt
das denn auch?}


\subsubsection{Ändern des Taktes von Elmi}
Ein SDH Multiplexer hat drei Betriebsarten, was den Takt angeht. Er kann sich auf den Netztakt aufsynchronisieren, einen externen Taktgeber nutzen, oder seine interne Clock als Taktgeber nutzen. Die meist verbreitete Betriebsart ist das Aufsynchronisieren auf den Netztakt. Dadurch wird sichergestellt, dass alle Multiplexer den selben Takt nutzen. Wie empfindlich ein SDH Netz auf Taktunterschiede reagiert, soll der nächste Versuch zeigen.

Um einen Taktunterschied zu provozieren, wird der Takt des Elmi auf den der internen Clock geändert. Direkt nach der Umstellung kann man einen hohen Sprung des +PJE Feldes beobachten. Dies zeigt, dass das System beginnt, sich zu synchronisieren. Nach dem starken Anstieg der positiv Pointer fällt die Anzahl der positiv Pointer wieder ab. Dieser Abfall zeigt, dass das System grundsätzlich wieder synchron ist. Obwohl das System wieder synchron ist, fällt auf, dass  das +PJE Feld weiter steigt, um etwa drei pro Sekunde. Die Erklärung dafür ist, dass der interne Takt von Elmi etwas langsamer ist als der des Netzes. So muss dieser positiv Inkrementieren um den Takt auszugleichen und das Netz synchron zu halten. \todo{Wer pointert?}


\subsubsection{Kontinuierliches negatives Justieren bei internem Takt}

Als letztes möchten wir gerne noch versuchen was passiert, wenn wir zusätzlich zu dem geändertem Takt noch negative Pointer Justierungen einspeisen. Bei Verwendung des internen Taktes von Elmi haben wir festgestellt, dass eine positive Pointerjustierung nötig ist, um das Netz synchron zu halten. \textcolor{red}{Wenn wir nun aber auf der Sende Seite den langsameren Takt durch negativ Justierung ausgleichen kann man beobachten wie die benötigten Pointer-Aktivitäten sinken.} \textcolor{blue}{Vorschlag: Zu den automatisch eingespeisten Positiv Pointern speisen wir nun Negativpointer ein. Zu erkennen ist, dass die Anzahl der Positivpointer zurück geht.} Wenn man das Intervall entsprechend weit verkleinern würde, \textcolor{red}{könnte man den kompletten ausgleich zwischen den unterschiedlichen Takten erreichen} \textcolor{blue}{könnte man erreichen, dass keine Pointer mehr mitgesendet werden. Der Hintergrund ist, dass wir durch die Pointerjustierung keinen echten Ausgleich der Taktunterschiede erreichen. Wir speisen lediglich Pointer ein. Da ein Pointer aber entweder positiv oder negativ sein kann, erreichen wir durch unsere künstlichen Negativpointer einen scheinbaren Ausgleich des Taktes.}

 In dem Versuch haben wir beobachtet wie sich die Pointerjustierung auswirkt. Dies ist hier noch einmal Tabellarsich aufgeführt.

\vspace{1 cm}
\begin{table}[H]
\begin{tabular}{|*{2}{c|}}
\hline
Justierung & PointerAktivität \\
\hline
Inkrementierung & 5 Pointer pro Sekunde\\
\hline
Dekrementierung & 3 Pointer pro Sekunde \\
\hline
Ohne & 4 Pointer pro Sekunde \\
\hline
\end{tabular}
\centering
\caption{Änderungen der Pointeraktivitäten bei internem Takt}
\end{table}
\vspace{1 cm}

%Die Tabelle zeigt auf, dass mit einer positiven Justierung des Pointers zusätzlich zu dem unterschiedlichen Takt eine noch höhere Pointer-Aktivität nötig ist um das System synchron zu halten. Wie oben beschrieben führt ein Dekrementieren zu einem annäherndem Ausgleich. Diese Aussage wird unterstützt wenn man sich die Spalte Ohne Justierung ansieht. Hier ist es etwa der Mittelwert der beiden anderen.

In der Tabelle ist zu erkennen, dass durch die Taktunterschiede zwischen Netz und Elmi vier Positivpointer benötigt werden. Durch zusätzliche Positivpointer steigt die Anzahl der Positivpointer auf fünf pro Sekunde. Speisen wir Nagativpointer ein, werden nur noch drei Pointer pro Sekunde gesendet.

\section{Fazit}

In den Versuchen wurde das bereits erlangte Wissen praktisch
angewandt. Vor allem in dem Bereichen Pointer wurden die das
Verständnis dafür sehr viel klarer und die Zusammenhänge eindeutiger.
Allerdings waren die Versuche alle sehr klar definiert und die
Erwartungen nicht überrascht. \todo{Keine Ahnung, was das bedeuten soll.}